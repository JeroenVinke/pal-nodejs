{"version":3,"sources":["polyfills/mutation-observer.ts"],"names":[],"mappings":";AAAA;;;;GAIG;;AAEH;IAIE,MAAM,CAAC,KAAK,CAAC,OAAO,EAAE,MAAM;QAC1B,IAAI,OAAO,GAAG,IAAI,CAAC,CAAC,2DAA2D;QAC/E,MAAM,CAAC,CAAC,cAAc,OAAO;YAC3B,IAAI,SAAS,GAAG;gBACd,mBAAmB;gBACnB,IAAI,EAAE,OAAO;gBACb,QAAQ,EAAE,IAAI;gBACd,IAAI,EAAE,IAAI;gBACV,IAAI,EAAE,IAAI;aACX,CAAC;YAEF,qFAAqF;YACrF,mCAAmC;YACnC,EAAE,CAAC,CAAC,MAAM,CAAC,QAAQ,IAAI,CAAC,OAAO,CAAC,QAAQ,KAAK,CAAC,IAAI,OAAO,CAAC,QAAQ,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;gBAC1E,SAAS,CAAC,QAAQ,GAAG,OAAO,CAAC,SAAS,CAAC;YACzC,CAAC;YAAC,IAAI,CAAC,CAAC;gBACN,kEAAkE;gBAClE,yCAAyC;gBACzC,EAAE,CAAC,CAAC,MAAM,CAAC,IAAI,IAAI,OAAO,IAAI,OAAO,CAAC,QAAQ,KAAK,CAAC,CAAC,CAAC,CAAC;oBACrD;;;sBAGE;oBACF,SAAS,CAAC,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,UAAU,EAAE,CAAC,IAAI,EAAE,IAAI;wBAC1D,EAAE,CAAC,CAAC,CAAC,MAAM,CAAC,OAAO,IAAI,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;4BACjD,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC;wBAC/B,CAAC;wBACD,MAAM,CAAC,IAAI,CAAC;oBACd,CAAC,EAAE,EAAE,CAAC,CAAC;gBACT,CAAC;gBAED,yDAAyD;gBACzD,EAAE,CAAC,CAAC,OAAO,IAAI,CAAC,CAAC,MAAM,CAAC,IAAI,IAAI,MAAM,CAAC,QAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,IAAI,MAAM,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,CAAC;oBACzF,sDAAsD;oBACtD,SAAS,CAAC,IAAI,GAAG,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,UAAU,EAAE,IAAI,CAAC,CAAC;gBACtD,CAAC;gBAED,OAAO,GAAG,MAAM,CAAC,WAAW,CAAC;YAC/B,CAAC;YACD,MAAM,CAAC,SAAS,CAAC;QACnB,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC;IACd,CAAC;IAED;;;;;;;MAOE;IACF,MAAM,CAAC,iBAAiB,CAAC,GAAG,EAAE,KAAK,EAAE,GAAG;QACtC,MAAM,yBAAyB,GAAG,CAAC,IAAI,CAAC,CAAC;QACzC,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,GAAG,EAAE,KAAK,EAAE,GAAG,EAAE,yBAAyB,CAAC,MAAM,CAAC,CAAC,CAAC;IAC1E,CAAC;IAED;;;;;MAKE;IACF,MAAM,CAAC,YAAY,CAAC,IAAI;QACtB,IAAI,CAAC;YACH,MAAM,CAAC,IAAI,CAAC,EAAE,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,GAAG,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,IAAI,IAAI,CAAC,OAAO,EAAE,CAAC,CAAC;QAChF,CAAC;QAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;YACX,IAAI,CAAC;gBACH,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,QAAQ;YACjC,CAAC;YAAC,KAAK,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC;gBAChB,MAAM,CAAC,IAAI,CAAC,OAAO,EAAE,CAAC;YACxB,CAAC;QACH,CAAC;IACH,CAAC;IAED;;;;MAIE;IACF,MAAM,CAAC,GAAG,CAAC,GAAG,EAAE,QAAQ;QACtB,IAAI,OAAO,GAAG,EAAE,CAAC;QACjB,GAAG,CAAC,CAAC,IAAI,KAAK,GAAG,CAAC,EAAE,KAAK,GAAG,GAAG,CAAC,MAAM,EAAE,KAAK,EAAE,EAAE,CAAC;YAChD,OAAO,CAAC,KAAK,CAAC,GAAG,QAAQ,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE,KAAK,EAAE,GAAG,CAAC,CAAC;QACpD,CAAC;QACD,MAAM,CAAC,OAAO,CAAC;IACjB,CAAC;IAED;;;;;MAKE;IACF,MAAM,CAAC,MAAM,CAAC,GAAG,EAAE,QAAQ,EAAE,IAAI;QAC/B,GAAG,CAAC,CAAC,IAAI,KAAK,GAAG,CAAC,EAAE,KAAK,GAAG,GAAG,CAAC,MAAM,EAAE,KAAK,EAAE,EAAE,CAAC;YAChD,IAAI,GAAG,QAAQ,CAAC,IAAI,EAAE,GAAG,CAAC,KAAK,CAAC,EAAE,KAAK,EAAE,GAAG,CAAC,CAAC;QAChD,CAAC;QACD,MAAM,CAAC,IAAI,CAAC;IACd,CAAC;IAED;;;;;;MAME;IACF,MAAM,CAAC,OAAO,CAAC,GAAG,EAAE,IAAI,EAAE,GAAG,EAAE,IAAK;QAClC,GAAG,CAAC,CAAC,EAAiB,GAAG,GAAG,GAAG,CAAC,MAAM,EAAE,GAAG,EAAE,EAAE,CAAC;YAC9C,EAAE,CAAC,CAAC,CAAC,IAAI,GAAG,GAAG,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,GAAG,CAAC,GAAG,CAAC,CAAC,KAAK,IAAI,CAAC;gBAAC,MAAM,CAAC,GAAG,CAAC;QAC9D,CAAC;QACD,MAAM,CAAC,CAAC,CAAC,CAAC;IACZ,CAAC;IAED;;;;MAIE;IACF,MAAM,CAAC,GAAG,CAAC,GAAG,EAAE,IAAI;QAClB,MAAM,CAAC,GAAG,CAAC,IAAI,CAAC,KAAK,SAAS,CAAC,CAAC,gCAAgC;IAClE,CAAC;;AA5HM,YAAO,GAAG,CAAC,CAAC;AACZ,YAAO,GAAG,OAAO,CAAC;AAF3B,oBA8HC;AAED;IAQE,YAAY,QAAQ;QAPZ,aAAQ,GAAG,EAAE,CAAC;QACd,cAAS,GAAG,IAAI,CAAC;QACjB,YAAO,GAAG,EAAE,CAAC;QACb,aAAQ,GAAG,IAAI,CAAC;QAChB,cAAS,GAAG,KAAK,CAAC;QAClB,oBAAe,GAAG,IAAI,CAAC;QAG7B,IAAI,CAAC,QAAQ,GAAG,EAAE,CAAC;QACnB,IAAI,CAAC,SAAS,GAAG,QAAQ,CAAC;QAC1B,IAAI,CAAC,OAAO,GAAG,EAAE,CAAC;QAClB,IAAI,CAAC,eAAe,GAAG,QAAQ,IAAI,CAAC,qBAAqB,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;IACrE,CAAC;IAED,OAAO,CAAC,OAAO,EAAE,MAAM;QACrB,IAAI,QAAQ,GAAG;YACb,IAAI,EAAE,CAAC,CAAC,CAAC,MAAM,CAAC,UAAU,IAAI,MAAM,CAAC,eAAe,IAAI,MAAM,CAAC,iBAAiB,CAAC;YAEjF,8FAA8F;YAC9F,mDAAmD;YACnD,IAAI,EAAE,CAAC,CAAC,MAAM,CAAC,SAAS;YACxB,WAAW,EAAE,CAAC,CAAC,MAAM,CAAC,OAAO;YAC7B,QAAQ,EAAE,CAAC,CAAC,CAAC,MAAM,CAAC,aAAa,IAAI,MAAM,CAAC,qBAAqB,CAAC;YAElE,OAAO,EAAE,IAAI;SACd,CAAC;QAEF,gBAAgB,CAAC,WAAW,EAAE,CAAC,EAAE,CAAC,SAAS,EAAE,IAAI,CAAC,eAAe,CAAC,CAAC;QAEnE,IAAI,OAAO,GAAG,IAAI,CAAC,QAAQ,CAAC;QAE5B,mDAAmD;QACnD,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,OAAO,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;YACxC,EAAE,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,GAAG,KAAK,OAAO,CAAC;gBAAC,OAAO,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QACvD,CAAC;QAED,EAAE,CAAC,CAAC,MAAM,CAAC,eAAe,CAAC,CAAC,CAAC;YAC3B;;;cAGE;YACF,QAAQ,CAAC,OAAO,GAAG,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,eAAe,EAAE,CAAC,CAAC,EAAE,CAAC;gBAC1D,CAAC,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC;gBACZ,MAAM,CAAC,CAAC,CAAC;YACX,CAAC,EAAE,EAAE,CAAC,CAAC;QACT,CAAC;QAED,OAAO,CAAC,IAAI,CAAC;YACX,GAAG,EAAE,OAAO;YACZ,EAAE,EAAE,IAAI,CAAC,sBAAsB,CAAC,OAAO,EAAE,QAAQ,CAAC;SACnD,CAAC,CAAC;IACL,CAAC;IAED,WAAW;QACT,IAAI,SAAS,GAAG,EAAE,CAAC;QACnB,IAAI,OAAO,GAAG,IAAI,CAAC,QAAQ,CAAC;QAE5B,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,OAAO,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;YACxC,OAAO,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,SAAS,CAAC,CAAC;QAC3B,CAAC;QAED,MAAM,CAAC,SAAS,CAAC;IACnB,CAAC;IAED,UAAU;QACR,IAAI,CAAC,QAAQ,GAAG,EAAE,CAAC,CAAC,iCAAiC;QACrD,gBAAgB,CAAC,WAAW,EAAE,CAAC,cAAc,CAAC,SAAS,EAAE,IAAI,CAAC,eAAe,CAAE,CAAC;QAChF,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC;QACtB,YAAY,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,+BAA+B;QAC5D,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;IACvB,CAAC;IAEO,sBAAsB,CAAC,OAAO,EAAE,MAAM;QAC5C,sBAAsB;QACtB,IAAI,SAAS,GAAG,IAAI,CAAC,KAAK,CAAC,OAAO,EAAE,MAAM,CAAC,CAAC,CAAC,kCAAkC;QAE/E;;;;UAIE;QACF,MAAM,CAAC,CAAC,SAAS;YACf,IAAI,IAAI,GAAG,SAAS,CAAC,MAAM,CAAC;YAC5B,IAAI,KAAK,CAAC;YAEV,EAAE,CAAC,CAAC,MAAM,CAAC,QAAQ,IAAI,OAAO,CAAC,QAAQ,KAAK,CAAC,IAAI,OAAO,CAAC,SAAS,KAAK,SAAS,CAAC,QAAQ,CAAC,CAAC,CAAC;gBAC1F,SAAS,CAAC,IAAI,CAAC,IAAI,cAAc,CAAC;oBAChC,IAAI,EAAE,eAAe;oBACrB,MAAM,EAAE,OAAO;oBACf,QAAQ,EAAE,SAAS,CAAC,QAAQ;iBAC7B,CAAC,CAAC,CAAC;YACN,CAAC;YAED,4DAA4D;YAC5D,EAAE,CAAC,CAAC,MAAM,CAAC,IAAI,IAAI,SAAS,CAAC,IAAI,CAAC,CAAC,CAAC;gBAClC,IAAI,CAAC,sBAAsB,CAAC,SAAS,EAAE,OAAO,EAAE,SAAS,CAAC,IAAI,EAAE,MAAM,CAAC,OAAO,CAAC,CAAC;YAClF,CAAC;YAED,2CAA2C;YAC3C,EAAE,CAAC,CAAC,MAAM,CAAC,IAAI,IAAI,MAAM,CAAC,WAAW,CAAC,CAAC,CAAC;gBACtC,KAAK,GAAG,IAAI,CAAC,aAAa,CAAC,SAAS,EAAE,OAAO,EAAE,SAAS,EAAE,MAAM,CAAC,CAAC;YACpE,CAAC;YAED,2CAA2C;YAC3C,EAAE,CAAC,CAAC,KAAK,IAAI,SAAS,CAAC,MAAM,KAAK,IAAI,CAAC,CAAC,CAAC;gBACvC,sBAAsB;gBACtB,SAAS,GAAG,IAAI,CAAC,KAAK,CAAC,OAAO,EAAE,MAAM,CAAC,CAAC;YAC1C,CAAC;QACH,CAAC,CAAC;IACJ,CAAC;IAEO,qBAAqB,CAAC,QAAQ;QACpC,iDAAiD;QACjD,EAAE,CAAC,CAAC,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC,CAAC;YACvB,QAAQ,CAAC,QAAQ,GAAG,UAAU,CAAC,MAAM,IAAI,CAAC,eAAe,CAAC,QAAQ,CAAC,EAAE,IAAI,CAAC,OAAO,CAAC,CAAC;QACrF,CAAC;IACH,CAAC;IAEO,eAAe,CAAC,QAAQ;QAC9B,iCAAiC;QACjC,QAAQ,CAAC,QAAQ,GAAG,IAAI,CAAC;QAEzB,IAAI,SAAS,GAAG,QAAQ,CAAC,WAAW,EAAE,CAAC;QAEvC,EAAE,CAAC,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC,CAAC;YACrB,4FAA4F;YAC5F,QAAQ,CAAC,SAAS,CAAC,SAAS,EAAE,QAAQ,CAAC,CAAC;QAC1C,CAAC;IACH,CAAC;IAEO,aAAa,CAAC,SAAS,EAAE,OAAO,EAAE,SAAS,EAAE,MAAM;QACzD,6DAA6D;QAC7D,IAAI,KAAK,CAAC;QACV;;;;;UAKE;QACF,MAAM,iBAAiB,GAAG,CAAC,SAAS,EAAE,IAAI,EAAE,KAAK,EAAE,QAAQ,EAAE,aAAa;YACxE,+DAA+D;YAC/D,IAAI,QAAQ,GAAG,SAAS,CAAC,MAAM,GAAG,CAAC,CAAC;YACpC,qFAAqF;YACrF,uFAAuF;YACvF,IAAI,OAAO,GAAG,CAAC,CAAC,CAAC,CAAC,QAAQ,GAAG,aAAa,CAAC,GAAG,CAAC,CAAC,CAAC;YACjD,IAAI,IAAI,CAAC;YACT,IAAI,SAAS,CAAC;YACd,IAAI,QAAQ,CAAC;YACb,OAAO,CAAC,QAAQ,GAAG,SAAS,CAAC,GAAG,EAAE,CAAC,EAAE,CAAC;gBACpC,IAAI,GAAG,KAAK,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;gBACzB,SAAS,GAAG,QAAQ,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;gBAEjC,sFAAsF;gBACtF,wFAAwF;gBACxF,EAAE,CAAC,CAAC,MAAM,CAAC,IAAI,IAAI,OAAO,IAAI,IAAI,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC,GAAG,QAAQ,CAAC,CAAC,CAAC,IAAI,QAAQ,CAAC,CAAC,CAAC;oBAC5E,SAAS,CAAC,IAAI,CAAC,IAAI,cAAc,CAAC;wBAChC,IAAI,EAAE,WAAW;wBACjB,MAAM,EAAE,IAAI;wBACZ,UAAU,EAAE,CAAC,IAAI,CAAC;wBAClB,YAAY,EAAE,CAAC,IAAI,CAAC;wBACpB,iCAAiC;wBACjC,WAAW,EAAE,IAAI,CAAC,WAAW;wBAC7B,eAAe,EAAE,IAAI,CAAC,eAAe;qBACtC,CAAC,CAAC,CAAC;oBACJ,OAAO,EAAE,CAAC,CAAC,iBAAiB;gBAC9B,CAAC;gBAED,6EAA6E;gBAC7E,EAAE,CAAC,CAAC,MAAM,CAAC,IAAI,IAAI,SAAS,CAAC,IAAI,CAAC;oBAAC,IAAI,CAAC,sBAAsB,CAAC,SAAS,EAAE,IAAI,EAAE,SAAS,CAAC,IAAI,EAAE,MAAM,CAAC,OAAO,CAAC,CAAC;gBAChH,EAAE,CAAC,CAAC,MAAM,CAAC,QAAQ,IAAI,IAAI,CAAC,QAAQ,KAAK,CAAC,IAAI,IAAI,CAAC,SAAS,KAAK,SAAS,CAAC,QAAQ,CAAC,CAAC,CAAC;oBACpF,SAAS,CAAC,IAAI,CAAC,IAAI,cAAc,CAAC;wBAChC,IAAI,EAAE,eAAe;wBACrB,MAAM,EAAE,IAAI;wBACZ,QAAQ,EAAE,SAAS,CAAC,QAAQ;qBAC7B,CAAC,CAAC,CAAC;gBACN,CAAC;gBACD,qBAAqB;gBACrB,EAAE,CAAC,CAAC,MAAM,CAAC,WAAW,CAAC;oBAAC,cAAc,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC;YAC1D,CAAC;QACH,CAAC,CAAC;QAEF;;;;UAIE;QACF,MAAM,cAAc,GAAG,CAAC,IAAI,EAAE,GAAG;YAC/B,IAAI,KAAK,GAAG,IAAI,CAAC,UAAU,CAAC;YAC5B,IAAI,QAAQ,GAAG,GAAG,CAAC,IAAI,CAAC;YACxB,IAAI,IAAI,GAAG,KAAK,CAAC,MAAM,CAAC;YACxB,wDAAwD;YACxD,IAAI,IAAI,GAAG,QAAQ,GAAG,QAAQ,CAAC,MAAM,GAAG,CAAC,CAAC;YAC1C,gEAAgE;YAEhE,uKAAuK;YACvK,+EAA+E;YAC/E,IAAI,GAAG,CAAC;YACR,yEAAyE;YACzE,IAAI,SAAS,CAAC;YACd,IAAI,EAAE,CAAC,CAAC,sCAAsC;YAC9C,IAAI,GAAG,CAAC,CAAC,uCAAuC;YAEhD,IAAI,SAAS,CAAC;YACd,wBAAwB;YACxB,IAAI,IAAI,CAAC;YACT,IAAI,IAAI,CAAC;YACT,8EAA8E;YAC9E,IAAI,aAAa,GAAG,CAAC,CAAC;YAEtB,iEAAiE;YACjE,IAAI,CAAC,GAAG,CAAC,CAAC;YACV,IAAI,CAAC,GAAG,CAAC,CAAC;YACV,6GAA6G;YAC7G,OAAO,CAAC,GAAG,IAAI,IAAI,CAAC,GAAG,IAAI,EAAE,CAAC;gBAC5B,sCAAsC;gBACtC,IAAI,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;gBAChB,SAAS,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC;gBACxB,IAAI,GAAG,SAAS,IAAI,SAAS,CAAC,IAAI,CAAC;gBAEnC,EAAE,CAAC,CAAC,IAAI,KAAK,IAAI,CAAC,CAAC,CAAC;oBAClB,0CAA0C;oBAC1C,EAAE,CAAC,CAAC,MAAM,CAAC,IAAI,IAAI,SAAS,CAAC,IAAI,CAAC,CAAC,CAAC;wBAClC,IAAI,CAAC,sBAAsB,CAAC,SAAS,EAAE,IAAI,EAAE,SAAS,CAAC,IAAI,EAAE,MAAM,CAAC,OAAO,CAAC,CAAC;oBAC/E,CAAC;oBACD,gFAAgF;oBAChF,EAAE,CAAC,CAAC,MAAM,CAAC,QAAQ,IAAI,SAAS,CAAC,QAAQ,KAAK,SAAS,IAAI,IAAI,CAAC,SAAS,KAAK,SAAS,CAAC,QAAQ,CAAC,CAAC,CAAC;wBACjG,SAAS,CAAC,IAAI,CAAC,IAAI,cAAc,CAAC;4BAChC,IAAI,EAAE,eAAe;4BACrB,MAAM,EAAE,IAAI;yBACb,CAAC,CAAC,CAAC;oBACN,CAAC;oBAED,yFAAyF;oBACzF,EAAE,CAAC,CAAC,SAAS,CAAC;wBAAC,iBAAiB,CAAC,SAAS,EAAE,IAAI,EAAE,KAAK,EAAE,QAAQ,EAAE,aAAa,CAAC,CAAC;oBAElF,0GAA0G;oBAC1G,EAAE,CAAC,CAAC,MAAM,CAAC,WAAW,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,MAAM,IAAI,SAAS,CAAC,IAAI,IAAI,SAAS,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;wBAAC,cAAc,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC;oBAE/H,CAAC,EAAE,CAAC;oBACJ,CAAC,EAAE,CAAC;gBACN,CAAC;gBAAC,IAAI,CAAC,CAAC;oBACN,KAAK,GAAG,IAAI,CAAC;oBACb,EAAE,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;wBACT,GAAG,GAAG,EAAE,CAAC;wBACT,SAAS,GAAG,EAAE,CAAC;oBACjB,CAAC;oBACD,EAAE,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC;wBACT,gEAAgE;wBAChE,EAAE,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,EAAE,GAAG,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;4BACzC,mBAAmB;4BACnB,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC;4BACf,oEAAoE;4BACpE,EAAE,CAAC,CAAC,CAAC,GAAG,GAAG,IAAI,CAAC,iBAAiB,CAAC,QAAQ,EAAE,IAAI,EAAE,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;gCAC7D,EAAE,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC;oCAChB,SAAS,CAAC,IAAI,CAAC,IAAI,cAAc,CAAC;wCAChC,IAAI,EAAE,WAAW;wCACjB,MAAM,EAAE,IAAI;wCACZ,UAAU,EAAE,CAAC,IAAI,CAAC;wCAClB,WAAW,EAAE,IAAI,CAAC,WAAW;wCAC7B,eAAe,EAAE,IAAI,CAAC,eAAe;qCACtC,CAAC,CAAC,CAAC;oCACJ,aAAa,EAAE,CAAC;gCAClB,CAAC;4BACH,CAAC;4BAAC,IAAI,CAAC,CAAC;gCACN,SAAS,CAAC,IAAI,CAAC;oCACb,CAAC,EAAE,CAAC;oCACJ,CAAC,EAAE,GAAG;iCACP,CAAC,CAAC;4BACL,CAAC;wBACH,CAAC;wBACD,CAAC,EAAE,CAAC;oBACN,CAAC;oBAED,EAAE,CAAC,CAAC,IAAI;wBACN,wHAAwH;wBACxH,IAAI,KAAK,KAAK,CAAC,CAAC,CAClB,CAAC,CAAC,CAAC;wBACD,EAAE,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,EAAE,GAAG,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;4BACzC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC;4BACf,EAAE,CAAC,CAAC,CAAC,GAAG,GAAG,IAAI,CAAC,OAAO,CAAC,KAAK,EAAE,IAAI,EAAE,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;gCAChD,EAAE,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC;oCAChB,SAAS,CAAC,IAAI,CAAC,IAAI,cAAc,CAAC;wCAChC,IAAI,EAAE,WAAW;wCACjB,MAAM,EAAE,GAAG,CAAC,IAAI;wCAChB,YAAY,EAAE,CAAC,IAAI,CAAC;wCACpB,WAAW,EAAE,QAAQ,CAAC,CAAC,GAAG,CAAC,CAAC;wCAC5B,eAAe,EAAE,QAAQ,CAAC,CAAC,GAAG,CAAC,CAAC;qCACjC,CAAC,CAAC,CAAC;oCACJ,aAAa,EAAE,CAAC;gCAClB,CAAC;4BACH,CAAC;4BAAC,IAAI,CAAC,CAAC;gCACN,SAAS,CAAC,IAAI,CAAC;oCACb,CAAC,EAAE,GAAG;oCACN,CAAC,EAAE,CAAC;iCACL,CAAC,CAAC;4BACL,CAAC;wBACH,CAAC;wBACD,CAAC,EAAE,CAAC;oBACN,CAAC;gBACH,CAAC,CAAA,oBAAoB;YACvB,CAAC,CAAA,WAAW;YAEZ,kCAAkC;YAClC,EAAE,CAAC,CAAC,SAAS,CAAC;gBAAC,iBAAiB,CAAC,SAAS,EAAE,IAAI,EAAE,KAAK,EAAE,QAAQ,EAAE,aAAa,CAAC,CAAC;QACpF,CAAC,CAAC;QACF,cAAc,CAAC,OAAO,EAAE,SAAS,CAAC,CAAC;QACnC,MAAM,CAAC,KAAK,CAAC;IACf,CAAC;IAEO,sBAAsB,CAAC,SAAS,EAAE,OAAO,EAAE,SAAS,EAAE,MAAM;QAClE,IAAI,OAAO,GAAG,EAAE,CAAC;QACjB,IAAI,UAAU,GAAG,OAAO,CAAC,UAAU,CAAC;QACpC,IAAI,IAAI,CAAC;QACT,IAAI,IAAI,CAAC;QACT,IAAI,CAAC,GAAG,UAAU,CAAC,MAAM,CAAC;QAC1B,OAAO,CAAC,EAAE,EAAE,CAAC;YACX,IAAI,GAAG,UAAU,CAAC,CAAC,CAAC,CAAC;YACrB,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;YACjB,EAAE,CAAC,CAAC,CAAC,MAAM,IAAI,IAAI,CAAC,GAAG,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC;gBACtC,EAAE,CAAC,CAAC,IAAI,CAAC,KAAK,KAAK,SAAS,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;oBACnC,iDAAiD;oBACjD,SAAS,CAAC,IAAI,CAAC,IAAI,cAAc,CAAC;wBAChC,IAAI,EAAE,YAAY;wBAClB,MAAM,EAAE,OAAO;wBACf,aAAa,EAAE,IAAI;wBACnB,QAAQ,EAAE,SAAS,CAAC,IAAI,CAAC;wBACzB,kBAAkB,EAAE,IAAI,CAAC,YAAY,CAAC,+CAA+C;qBACtF,CAAC,CAAC,CAAC;gBACN,CAAC;gBACD,OAAO,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC;YACvB,CAAC;QACH,CAAC;QACD,GAAG,CAAC,CAAC,IAAI,IAAI,SAAS,CAAC,CAAC,CAAC;YACvB,EAAE,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;gBACrB,SAAS,CAAC,IAAI,CAAC,IAAI,cAAc,CAAC;oBAChC,MAAM,EAAE,OAAO;oBACf,IAAI,EAAE,YAAY;oBAClB,aAAa,EAAE,IAAI;oBACnB,QAAQ,EAAE,SAAS,CAAC,IAAI,CAAC;iBAC1B,CAAC,CAAC,CAAC;YACN,CAAC;QACH,CAAC;IACH,CAAC;CACF;AAxVD,4CAwVC;AAED;IACE,YAAY,IAAI;QACd,IAAI,QAAQ,GAAG;YACb,IAAI,EAAE,IAAI;YACV,MAAM,EAAE,IAAI;YACZ,UAAU,EAAE,EAAE;YACd,YAAY,EAAE,EAAE;YAChB,eAAe,EAAE,IAAI;YACrB,WAAW,EAAE,IAAI;YACjB,aAAa,EAAE,IAAI;YACnB,kBAAkB,EAAE,IAAI;YACxB,QAAQ,EAAE,IAAI;SACf,CAAC;QACF,GAAG,CAAC,CAAC,IAAI,IAAI,IAAI,IAAI,CAAC,CAAC,CAAC;YACtB,EAAE,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,QAAQ,EAAE,IAAI,CAAC,IAAI,IAAI,CAAC,IAAI,CAAC,KAAK,SAAS,CAAC;gBAAC,QAAQ,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,IAAI,CAAC,CAAC;QACxF,CAAC;QACD,MAAM,CAAC,QAAQ,CAAC;IAClB,CAAC;CACF;AAlBD,wCAkBC;AAED,mCAAsC;AAEtC,sBAA8B,SAAQ,qBAAY;IAUhD;QACE,KAAK,EAAE,CAAC;QACR,IAAI,CAAC,eAAe,CAAC,GAAG,CAAC,CAAC;IAC5B,CAAC;IAVD,MAAM,CAAC,WAAW;QAChB,EAAE,CAAC,CAAC,CAAC,gBAAgB,CAAC,SAAS,CAAC,CAAC,CAAC;YAChC,gBAAgB,CAAC,SAAS,GAAG,IAAI,gBAAgB,EAAE,CAAC;QACtD,CAAC;QACD,MAAM,CAAC,gBAAgB,CAAC,SAAS,CAAC;IACpC,CAAC;IAOD,QAAQ;QACN,IAAI,CAAC,kBAAkB,CAAC,SAAS,CAAC,CAAC;IACrC,CAAC;IAED,aAAa,CAAC,IAAU;QACtB,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE,IAAI,CAAC,CAAC;IAC7B,CAAC;;AApBc,0BAAS,GAAqB,IAAI,CAAC;AADpD,4CAsBC","file":"mutation-observer.js","sourcesContent":["/*\r\n * Based on Shim for MutationObserver interface\r\n * Author: Graeme Yeates (github.com/megawac)\r\n * Repository: https://github.com/megawac/MutationObserver.js\r\n */\r\n\r\nexport class Util {\r\n  static counter = 1;\r\n  static expando = 'mo_id';\r\n\r\n  static clone($target, config) {\r\n    let recurse = true; // set true so childList we'll always check the first level\r\n    return (function copy($target) {\r\n      let elestruct = {\r\n        /** @type {Node} */\r\n        node: $target,\r\n        charData: null,\r\n        attr: null,\r\n        kids: null,\r\n      };\r\n\r\n      // Store current character data of target text or comment node if the config requests\r\n      // those properties to be observed.\r\n      if (config.charData && ($target.nodeType === 3 || $target.nodeType === 8)) {\r\n        elestruct.charData = $target.nodeValue;\r\n      } else {\r\n        // Add attr only if subtree is specified or top level and avoid if\r\n        // attributes is a document object (#13).\r\n        if (config.attr && recurse && $target.nodeType === 1) {\r\n          /**\r\n          * clone live attribute list to an object structure {name: val}\r\n          * @type {Object.<string, string>}\r\n          */\r\n          elestruct.attr = Util.reduce($target.attributes, (memo, attr) => {\r\n            if (!config.afilter || config.afilter[attr.name]) {\r\n              memo[attr.name] = attr.value;\r\n            }\r\n            return memo;\r\n          }, {});\r\n        }\r\n\r\n        // whether we should iterate the children of $target node\r\n        if (recurse && ((config.kids || config.charData) || (config.attr && config.descendents))) {\r\n          /** @type {Array.<!Object>} : Array of custom clone */\r\n          elestruct.kids = Util.map($target.childNodes, copy);\r\n        }\r\n\r\n        recurse = config.descendents;\r\n      }\r\n      return elestruct;\r\n    })($target);\r\n  }\r\n\r\n  /**\r\n  * indexOf an element in a collection of custom nodes\r\n  *\r\n  * @param {NodeList} set\r\n  * @param {!Object} $node : A custom cloned nodeg333\r\n  * @param {number} idx : index to start the loop\r\n  * @return {number}\r\n  */\r\n  static indexOfCustomNode(set, $node, idx) {\r\n    const JSCompiler_renameProperty = a => a;\r\n    return this.indexOf(set, $node, idx, JSCompiler_renameProperty('node'));\r\n  }\r\n\r\n  /**\r\n  * Attempt to uniquely id an element for hashing. We could optimize this for legacy browsers but it hopefully wont be called enough to be a concern\r\n  *\r\n  * @param {Node} $ele\r\n  * @return {(string|number)}\r\n  */\r\n  static getElementId($ele) {\r\n    try {\r\n      return $ele.id || ($ele[this.expando] = $ele[this.expando] || this.counter++);\r\n    } catch (e) { // ie <8 will throw if you set an unknown property on a text node\r\n      try {\r\n        return $ele.nodeValue; // naive\r\n      } catch (shitie) { // when text node is removed: https://gist.github.com/megawac/8355978 :(\r\n        return this.counter++;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n  * **map** Apply a mapping function to each item of a set\r\n  * @param {Array|NodeList} set\r\n  * @param {Function} iterator\r\n  */\r\n  static map(set, iterator) {\r\n    let results = [];\r\n    for (let index = 0; index < set.length; index++) {\r\n      results[index] = iterator(set[index], index, set);\r\n    }\r\n    return results;\r\n  }\r\n\r\n  /**\r\n  * **Reduce** builds up a single result from a list of values\r\n  * @param {Array|NodeList|NamedNodeMap} set\r\n  * @param {Function} iterator\r\n  * @param {*} [memo] Initial value of the memo.\r\n  */\r\n  static reduce(set, iterator, memo) {\r\n    for (let index = 0; index < set.length; index++) {\r\n      memo = iterator(memo, set[index], index, set);\r\n    }\r\n    return memo;\r\n  }\r\n\r\n  /**\r\n  * **indexOf** find index of item in collection.\r\n  * @param {Array|NodeList} set\r\n  * @param {Object} item\r\n  * @param {number} idx\r\n  * @param {string} [prop] Property on set item to compare to item\r\n  */\r\n  static indexOf(set, item, idx, prop?) {\r\n    for (/*idx = ~~idx*/; idx < set.length; idx++) {// start idx is always given as this is internal\r\n      if ((prop ? set[idx][prop] : set[idx]) === item) return idx;\r\n    }\r\n    return -1;\r\n  }\r\n\r\n  /**\r\n  * @param {Object} obj\r\n  * @param {(string|number)} prop\r\n  * @return {boolean}\r\n  */\r\n  static has(obj, prop) {\r\n    return obj[prop] !== undefined; // will be nicely inlined by gcc\r\n  }\r\n}\r\n\r\nexport class MutationObserver {\r\n  private _watched = [];\r\n  private _listener = null;\r\n  private _period = 30;\r\n  private _timeout = null;\r\n  private _disposed = false;\r\n  private _notifyListener = null;\r\n\r\n  constructor(listener) {\r\n    this._watched = [];\r\n    this._listener = listener;\r\n    this._period = 30;\r\n    this._notifyListener = () => { this.scheduleMutationCheck(this); };\r\n  }\r\n\r\n  observe($target, config) {\r\n    let settings = {\r\n      attr: !!(config.attributes || config.attributeFilter || config.attributeOldValue),\r\n\r\n      // some browsers enforce that subtree must be set with childList, attributes or characterData.\r\n      // We don't care as spec doesn't specify this rule.\r\n      kids: !!config.childList,\r\n      descendents: !!config.subtree,\r\n      charData: !!(config.characterData || config.characterDataOldValue),\r\n\r\n      afilter: null\r\n    };\r\n\r\n    MutationNotifier.getInstance().on(\"changed\", this._notifyListener);\r\n\r\n    let watched = this._watched;\r\n\r\n    // remove already observed target element from pool\r\n    for (let i = 0; i < watched.length; i++) {\r\n      if (watched[i].tar === $target) watched.splice(i, 1);\r\n    }\r\n\r\n    if (config.attributeFilter) {\r\n      /**\r\n      * converts to a {key: true} dict for faster lookup\r\n      * @type {Object.<String,Boolean>}\r\n      */\r\n      settings.afilter = Util.reduce(config.attributeFilter, (a, b) => {\r\n        a[b] = true;\r\n        return a;\r\n      }, {});\r\n    }\r\n\r\n    watched.push({\r\n      tar: $target,\r\n      fn: this.createMutationSearcher($target, settings)\r\n    });\r\n  }\r\n\r\n  takeRecords() {\r\n    let mutations = [];\r\n    let watched = this._watched;\r\n\r\n    for (let i = 0; i < watched.length; i++) {\r\n      watched[i].fn(mutations);\r\n    }\r\n\r\n    return mutations;\r\n  }\r\n\r\n  disconnect() {\r\n    this._watched = []; // clear the stuff being observed\r\n    MutationNotifier.getInstance().removeListener(\"changed\", this._notifyListener );\r\n    this._disposed = true;\r\n    clearTimeout(this._timeout); // ready for garbage collection\r\n    this._timeout = null;\r\n  }\r\n\r\n  private createMutationSearcher($target, config) {\r\n    /** type {Elestuct} */\r\n    let $oldstate = Util.clone($target, config); // create the cloned datastructure\r\n\r\n    /**\r\n    * consumes array of mutations we can push to\r\n    *\r\n    * @param {Array.<MutationRecord>} mutations\r\n    */\r\n    return (mutations) => {\r\n      let olen = mutations.length;\r\n      let dirty;\r\n\r\n      if (config.charData && $target.nodeType === 3 && $target.nodeValue !== $oldstate.charData) {\r\n        mutations.push(new MutationRecord({\r\n          type: 'characterData',\r\n          target: $target,\r\n          oldValue: $oldstate.charData\r\n        }));\r\n      }\r\n\r\n      // Alright we check base level changes in attributes... easy\r\n      if (config.attr && $oldstate.attr) {\r\n        this.findAttributeMutations(mutations, $target, $oldstate.attr, config.afilter);\r\n      }\r\n\r\n      // check childlist or subtree for mutations\r\n      if (config.kids || config.descendents) {\r\n        dirty = this.searchSubtree(mutations, $target, $oldstate, config);\r\n      }\r\n\r\n      // reclone data structure if theres changes\r\n      if (dirty || mutations.length !== olen) {\r\n        /** type {Elestuct} */\r\n        $oldstate = Util.clone($target, config);\r\n      }\r\n    };\r\n  }\r\n\r\n  private scheduleMutationCheck(observer) {\r\n    // Only schedule if there isn't already a timer. \r\n    if (!observer._timeout) {\r\n      observer._timeout = setTimeout(() => this.mutationChecker(observer), this._period);\r\n    }\r\n  }\r\n\r\n  private mutationChecker(observer) {\r\n    // allow scheduling a new timer. \r\n    observer._timeout = null; \r\n    \r\n    let mutations = observer.takeRecords();\r\n\r\n    if (mutations.length) { // fire away\r\n      // calling the listener with context is not spec but currently consistent with FF and WebKit\r\n      observer._listener(mutations, observer);\r\n    }\r\n  }\r\n\r\n  private searchSubtree(mutations, $target, $oldstate, config) {\r\n    // Track if the tree is dirty and has to be recomputed (#14).\r\n    let dirty;\r\n    /*\r\n    * Helper to identify node rearrangment and stuff...\r\n    * There is no gaurentee that the same node will be identified for both added and removed nodes\r\n    * if the positions have been shuffled.\r\n    * conflicts array will be emptied by end of operation\r\n    */\r\n    const _resolveConflicts = (conflicts, node, $kids, $oldkids, numAddedNodes) => {\r\n      // the distance between the first conflicting node and the last\r\n      let distance = conflicts.length - 1;\r\n      // prevents same conflict being resolved twice consider when two nodes switch places.\r\n      // only one should be given a mutation event (note -~ is used as a math.ceil shorthand)\r\n      let counter = -~((distance - numAddedNodes) / 2);\r\n      let $cur;\r\n      let oldstruct;\r\n      let conflict;\r\n      while ((conflict = conflicts.pop())) {\r\n        $cur = $kids[conflict.i];\r\n        oldstruct = $oldkids[conflict.j];\r\n\r\n        // attempt to determine if there was node rearrangement... won't gaurentee all matches\r\n        // also handles case where added/removed nodes cause nodes to be identified as conflicts\r\n        if (config.kids && counter && Math.abs(conflict.i - conflict.j) >= distance) {\r\n          mutations.push(new MutationRecord({\r\n            type: 'childList',\r\n            target: node,\r\n            addedNodes: [$cur],\r\n            removedNodes: [$cur],\r\n            // haha don't rely on this please\r\n            nextSibling: $cur.nextSibling,\r\n            previousSibling: $cur.previousSibling\r\n          }));\r\n          counter--; // found conflict\r\n        }\r\n\r\n        // Alright we found the resorted nodes now check for other types of mutations\r\n        if (config.attr && oldstruct.attr) this.findAttributeMutations(mutations, $cur, oldstruct.attr, config.afilter);\r\n        if (config.charData && $cur.nodeType === 3 && $cur.nodeValue !== oldstruct.charData) {\r\n          mutations.push(new MutationRecord({\r\n            type: 'characterData',\r\n            target: $cur,\r\n            oldValue: oldstruct.charData\r\n          }));\r\n        }\r\n        // now look @ subtree\r\n        if (config.descendents) _findMutations($cur, oldstruct);\r\n      }\r\n    };\r\n\r\n    /**\r\n    * Main worker. Finds and adds mutations if there are any\r\n    * @param {Node} node\r\n    * @param {!Object} old : A cloned data structure using internal clone\r\n    */\r\n    const _findMutations = (node, old) => {\r\n      let $kids = node.childNodes;\r\n      let $oldkids = old.kids;\r\n      let klen = $kids.length;\r\n      // $oldkids will be undefined for text and comment nodes\r\n      let olen = $oldkids ? $oldkids.length : 0;\r\n      // if (!olen && !klen) return; // both empty; clearly no changes\r\n\r\n      // we delay the intialization of these for marginal performance in the expected case (actually quite signficant on large subtrees when these would be otherwise unused)\r\n      // map of checked element of ids to prevent registering the same conflict twice\r\n      let map;\r\n      // array of potential conflicts (ie nodes that may have been re arranged)\r\n      let conflicts;\r\n      let id; // element id from getElementId helper\r\n      let idx; // index of a moved or inserted element\r\n\r\n      let oldstruct;\r\n      // current and old nodes\r\n      let $cur;\r\n      let $old;\r\n      // track the number of added nodes so we can resolve conflicts more accurately\r\n      let numAddedNodes = 0;\r\n\r\n      // iterate over both old and current child nodes at the same time\r\n      let i = 0;\r\n      let j = 0;\r\n      // while there is still anything left in $kids or $oldkids (same as i < $kids.length || j < $oldkids.length;)\r\n      while (i < klen || j < olen) {\r\n        // current and old nodes at the indexs\r\n        $cur = $kids[i];\r\n        oldstruct = $oldkids[j];\r\n        $old = oldstruct && oldstruct.node;\r\n\r\n        if ($cur === $old) { // expected case - optimized for this case\r\n          // check attributes as specified by config\r\n          if (config.attr && oldstruct.attr) {/* oldstruct.attr instead of textnode check */\r\n            this.findAttributeMutations(mutations, $cur, oldstruct.attr, config.afilter);\r\n          }\r\n          // check character data if node is a comment or textNode and it's being observed\r\n          if (config.charData && oldstruct.charData !== undefined && $cur.nodeValue !== oldstruct.charData) {\r\n            mutations.push(new MutationRecord({\r\n              type: 'characterData',\r\n              target: $cur\r\n            }));\r\n          }\r\n\r\n          // resolve conflicts; it will be undefined if there are no conflicts - otherwise an array\r\n          if (conflicts) _resolveConflicts(conflicts, node, $kids, $oldkids, numAddedNodes);\r\n\r\n          // recurse on next level of children. Avoids the recursive call when there are no children left to iterate\r\n          if (config.descendents && ($cur.childNodes.length || oldstruct.kids && oldstruct.kids.length)) _findMutations($cur, oldstruct);\r\n\r\n          i++;\r\n          j++;\r\n        } else { // (uncommon case) lookahead until they are the same again or the end of children\r\n          dirty = true;\r\n          if (!map) { // delayed initalization (big perf benefit)\r\n            map = {};\r\n            conflicts = [];\r\n          }\r\n          if ($cur) {\r\n            // check id is in the location map otherwise do a indexOf search\r\n            if (!(map[id = Util.getElementId($cur)])) { // to prevent double checking\r\n              // mark id as found\r\n              map[id] = true;\r\n              // custom indexOf using comparitor checking oldkids[i].node === $cur\r\n              if ((idx = Util.indexOfCustomNode($oldkids, $cur, j)) === -1) {\r\n                if (config.kids) {\r\n                  mutations.push(new MutationRecord({\r\n                    type: 'childList',\r\n                    target: node,\r\n                    addedNodes: [$cur], // $cur is a new node\r\n                    nextSibling: $cur.nextSibling,\r\n                    previousSibling: $cur.previousSibling\r\n                  }));\r\n                  numAddedNodes++;\r\n                }\r\n              } else {\r\n                conflicts.push({ // add conflict\r\n                  i: i,\r\n                  j: idx\r\n                });\r\n              }\r\n            }\r\n            i++;\r\n          }\r\n\r\n          if ($old &&\r\n            // special case: the changes may have been resolved: i and j appear congurent so we can continue using the expected case\r\n            $old !== $kids[i]\r\n          ) {\r\n            if (!(map[id = Util.getElementId($old)])) {\r\n              map[id] = true;\r\n              if ((idx = Util.indexOf($kids, $old, i)) === -1) {\r\n                if (config.kids) {\r\n                  mutations.push(new MutationRecord({\r\n                    type: 'childList',\r\n                    target: old.node,\r\n                    removedNodes: [$old],\r\n                    nextSibling: $oldkids[j + 1], // praise no indexoutofbounds exception\r\n                    previousSibling: $oldkids[j - 1]\r\n                  }));\r\n                  numAddedNodes--;\r\n                }\r\n              } else {\r\n                conflicts.push({\r\n                  i: idx,\r\n                  j: j\r\n                });\r\n              }\r\n            }\r\n            j++;\r\n          }\r\n        }// end uncommon case\r\n      }// end loop\r\n\r\n      // resolve any remaining conflicts\r\n      if (conflicts) _resolveConflicts(conflicts, node, $kids, $oldkids, numAddedNodes);\r\n    };\r\n    _findMutations($target, $oldstate);\r\n    return dirty;\r\n  }\r\n\r\n  private findAttributeMutations(mutations, $target, $oldstate, filter) {\r\n    let checked = {};\r\n    let attributes = $target.attributes;\r\n    let attr;\r\n    let name;\r\n    let i = attributes.length;\r\n    while (i--) {\r\n      attr = attributes[i];\r\n      name = attr.name;\r\n      if (!filter || Util.has(filter, name)) {\r\n        if (attr.value !== $oldstate[name]) {\r\n          // The pushing is redundant but gzips very nicely\r\n          mutations.push(new MutationRecord({\r\n            type: 'attributes',\r\n            target: $target,\r\n            attributeName: name,\r\n            oldValue: $oldstate[name],\r\n            attributeNamespace: attr.namespaceURI // in ie<8 it incorrectly will return undefined\r\n          }));\r\n        }\r\n        checked[name] = true;\r\n      }\r\n    }\r\n    for (name in $oldstate) {\r\n      if (!(checked[name])) {\r\n        mutations.push(new MutationRecord({\r\n          target: $target,\r\n          type: 'attributes',\r\n          attributeName: name,\r\n          oldValue: $oldstate[name]\r\n        }));\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport class MutationRecord {\r\n  constructor(data) {\r\n    let settings = { // technically these should be on proto so hasOwnProperty will return false for non explicitly props\r\n      type: null,\r\n      target: null,\r\n      addedNodes: [],\r\n      removedNodes: [],\r\n      previousSibling: null,\r\n      nextSibling: null,\r\n      attributeName: null,\r\n      attributeNamespace: null,\r\n      oldValue: null\r\n    };\r\n    for (let prop in data) {\r\n      if (Util.has(settings, prop) && data[prop] !== undefined) settings[prop] = data[prop];\r\n    }\r\n    return settings;\r\n  }\r\n}\r\n\r\nimport { EventEmitter } from 'events';\r\n\r\nexport class MutationNotifier extends EventEmitter {\r\n  private static _instance: MutationNotifier = null;\r\n\r\n  static getInstance() {\r\n    if (!MutationNotifier._instance) {\r\n      MutationNotifier._instance = new MutationNotifier();\r\n    }\r\n    return MutationNotifier._instance;\r\n  }\r\n\r\n  constructor() {\r\n    super();\r\n    this.setMaxListeners(100);\r\n  }\r\n\r\n  destruct() {\r\n    this.removeAllListeners(\"changed\");\r\n  }\r\n\r\n  notifyChanged(node: Node) {\r\n    this.emit(\"changed\", node);\r\n  }\r\n}"],"sourceRoot":"../../../src/"}